package maestro.blackjack;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.concurrent.TimeUnit;

import com.jagrosh.jdautilities.commons.waiter.EventWaiter;

import maestro.Bot;
import maestro.blackjack.LinkedList.Node;
import maestro.blackjack.objects.Card;
import maestro.blackjack.objects.Deck;
import maestro.blackjack.objects.Player;
import net.dv8tion.jda.api.EmbedBuilder;
import net.dv8tion.jda.api.Permission;
import net.dv8tion.jda.api.entities.channel.concrete.TextChannel;
import net.dv8tion.jda.api.entities.User;
import net.dv8tion.jda.api.events.interaction.component.ButtonInteractionEvent;
import net.dv8tion.jda.api.events.message.MessageReceivedEvent;
import net.dv8tion.jda.api.interactions.components.ActionRow;
import net.dv8tion.jda.api.interactions.components.buttons.Button;

public class Game {
	
	private LinkedList players;
	private Node firstPlayerNode;
	private Deck deck;
	private Player dealer;
	private TextChannel channel;
	private EventWaiter waiter = Bot.waiter;
	public boolean started = false;
	private Connection conn;
	
	
	/**
	 * Creates a new instance of Game (one per guild, unless there is demand for multiple games, but that is unsafe).
	 * @param numDecks The number of decks to be played (default 6)
	 * @param channel The channel in which to play the game
	 * @param players The ArrayList of Players generated by the GuildGameMnaager
	 * @param conn The connection to the database
	 */
	public Game(int numDecks, TextChannel channel, ArrayList<Player> players, Connection conn) {
		this.players = new LinkedList(players);
		firstPlayerNode = this.players.getHeadNode();
		deck = new Deck(true, numDecks);
		this.channel = channel;
		dealer = new Player();
		this.conn = conn;
	}
	
	/**
	 * The first method to be called in order to start the game. Resets everyone's hands and displays everyone's balances.
	 * Calls setBet()
	 */
	public void run() {
		dealer.resetHand();
		EmbedBuilder eb = new EmbedBuilder();
		
		
		for(Node ptr = firstPlayerNode; ptr != null; ptr = ptr.next) { 
			ptr.getPlayer().resetHand();
			eb.addField(channel.getGuild().getMember(ptr.getPlayer().getUser()).getEffectiveName(), String.format("$%.2f", ptr.getPlayer().getCash()), false);
		}
		
		eb
				.setTitle("current balances")
				.setThumbnail(channel.getJDA().getSelfUser().getAvatarUrl());
		channel.sendMessageEmbeds(eb.build()).queue();
		
		//because of the way eventwaiter's lambda functions, we need to have everything linked starting from this method
		setBet(firstPlayerNode);
	
		
	}
	
	/**
	 * Takes input from a player to determine their bet.
	 * Calls dealToPlayers()
	 * @param playerNode The Node of the player who's bet is being set.
	 */
	private void setBet(Node playerNode) {
		Player player = playerNode.getPlayer();
		
		channel.sendMessage(player.getUser().getAsMention() + ", please enter your bet").queue();
		waiter.waitForEvent(MessageReceivedEvent.class, 
			(e) -> {
				if(e.getAuthor().isBot() || !e.getAuthor().equals(player.getUser()) || !e.getChannel().asTextChannel().equals(channel)) {
					return false;
				}
				
				try {
					double i = Double.parseDouble(e.getMessage().getContentRaw());
					if(i <= 0) {
						channel.sendMessage("bet must be positive").queue();
						return false;
					}
					
					if(i > player.getCash()) {
						channel.sendMessage("you don't have enough money broke ass").queue();
						return false;
					}
					
				} catch (Exception x){
					channel.sendMessage("please enter a number").queue();
					return false;
				}
				
				return true;
			}, 
			
			(e) -> {
				double i = Double.parseDouble(e.getMessage().getContentRaw());
				player.setWager(i);
				if(playerNode.next == null)
					dealToPlayers();
				else 
					setBet(playerNode.next);
			}, 30, TimeUnit.SECONDS, () -> {
				channel.sendMessage("you took too long betting, default bet set (0)").queue();
				player.setWager(0);
				//send to next method
				if(playerNode.next == null)
					dealToPlayers();
				else 
					setBet(playerNode.next);
			});
		
	}
	
	/**
	 * Begins the initial deal, where each player, including the dealer, gets dealt two cards. The dealer's second card will be face down.
	 * Will call insuranceSituation() if the dealer has been dealt an ace and players are eligible. 
	 * Will call payout() if the dealer has been dealt a blackjack immediately.
	 * Will call splitSituation() if any of the players are able to split their hand.
	 * Will call turn() if nothing significant has happened.
	 */
	private void dealToPlayers() {
		EmbedBuilder eb = new EmbedBuilder()
				.setTitle("dealing")
				.setDescription("maestro is dealing cards, please wait")
				.setThumbnail(channel.getJDA().getSelfUser().getAvatarUrl());
		channel.sendMessageEmbeds(eb.build()).queue();
		
		//a card is dealt to every player once (including the dealer) before dealing the second card to all players
		for(int i = 0; i < 2; i++) {
			Card dealingCard;
			
			//deal to player
			for(Node ptr = firstPlayerNode; ptr != null; ptr = ptr.next) {
				dealingCard = deck.deal();
				Player player = ptr.getPlayer();
				channel.sendMessage("dealing to " + player.getUser().getAsMention() + ": " + dealingCard.toString()).queue();
				player.getHand().add(dealingCard);
			}
			
			//deal to dealer
			dealingCard = deck.deal();
			if(i==0) {
				channel.sendMessage("dealing to DEALER: " + dealingCard.toString()).queue();
			} else {
				channel.sendMessage("dealing to DEALER: *FACE DOWN*").queue();
			}
			dealer.getHand().add(dealingCard);
		}		
		
		if(dealer.getHand().get(0).getValue() == 1) {
			boolean eligible = false;
			
			//iterate through player list to determine eligibility
			for(Node ptr = firstPlayerNode; ptr != null; ptr = ptr.next) { 
				Player player = ptr.getPlayer();	
				
				if(!eligible)		
					eligible = player.getCash() > 0;
			}
			
			if(eligible) {
				channel.sendMessage("the dealer has been dealt an ace, some players are eligible for insurance").queue();
				insuranceSituation(firstPlayerNode);
				return;
			}
		}
		
		//if dealer has blackjack, than none of the players should be allowed to play
		if(dealer.getHand().get(0).getValue() == 10 || dealer.getHand().get(0).getValue() == 1) {
			channel.sendMessage("dealer is checking face down card...").queue();
		}
		
		if(dealer.hasBlackjack()) { 
			channel.sendMessage(dealer.getHand().get(1).toString()).queue();
			channel.sendMessage("dealer has blackjack!").queue();
			channel.sendMessage("──────────────────────────────────────").queue();
			payout();     
			return;
		}
		
		channel.sendMessage("──────────────────────────────────────").queue();
		
		//there is no need to iterate through all players to determine if anyone can split, as splitSituation() will do it anyways
		//		maybe do the same for insuranceSituation()??
		splitSituation(firstPlayerNode);
	}
	
	/**
	 * A player can split their hand if the two initial cards are of the same rank (not value!). When a player splits, their hand is split into two separate hands whose bet will be equal
	 * to their original bet, each hand having one of the cards from the original hand. These hands will be separate from each other, and can both play its own turn. In other words, the 
	 * hand's values will not be combined, they will be treated as if they're two separate players.
	 * <p>
	 * This is an  intermediary method, between the dealing and the playing. It will check if a player can split, and will split their hand if they choose to do.
	 * This has to be here as the player must enter input. The EventWaiter can only be called once a method, as the lambda functions are going to be asynchronous.
	 * Calls splitSituation() for the next player, or turn() for the firstPlayerNode if there is no next player.
	 * </p>
	 * @param playerNode The node of the player whose hand will be split if the player can and wants to.
	 */
	private void splitSituation(Node playerNode) {
		Player player = playerNode.getPlayer();
		
		//ask here what the player would like to do if they want to split hands
		//	iterate through list for multiple players
		if(player.canSplit()) {
			EmbedBuilder ebSpl = new EmbedBuilder()
					.setTitle("split hand")
					.setDescription(channel.getGuild().getMember(player.getUser()).getEffectiveName() + ", you are able to split your hand. this split hand will have the same bet as your original bet. would you like to split?")
					.setThumbnail(player.getUser().getAvatarUrl());
			
			channel.sendMessageEmbeds(ebSpl.build()).setActionRow(Button.success("blackjack:yes_split_button", "split"), Button.danger("blackjack:no_split_button", "no")).queue( m ->
			waiter.waitForEvent(ButtonInteractionEvent.class, 
				(e) -> {
					return e.getUser().equals(player.getUser()) && m.getIdLong() == e.getMessageIdLong();
				}, e -> {
					e.editComponents().queue();
					
					if(e.getComponentId().equals("blackjack:yes_split_button")) {
						player.splitPlayerHand();
						channel.sendMessage(player.getUser().getAsMention() + " splits their hand\nsplit hand: " + player.getSplitHand().getHand().toString()).queue();
						Node splitNode = new Node(player.getSplitHand(), playerNode.next, playerNode);
						playerNode.next = splitNode;
						
						if(splitNode.next == null) 
							turn(firstPlayerNode);
						else
							splitSituation(splitNode.next);
					}
					
					if(e.getComponentId().equals("blackjack:no_split_button")) {
						if(playerNode.next == null) 
							turn(firstPlayerNode);
						else
							splitSituation(playerNode.next);
					}
				}, 30, TimeUnit.SECONDS, () -> {
					channel.sendMessage("you took too long, will not split hand").queue();
					if(playerNode.next == null) 
						turn(firstPlayerNode);
					else
						splitSituation(playerNode.next);
				}));
		} else {
			if(playerNode.next == null) 
				turn(firstPlayerNode);
			else
				splitSituation(playerNode.next);
		}
	}
	
	/**
	 * A player can place an insurance bet when the dealer's face up card is an ace, which will be paid back 2:1 if the dealer gets blackjack. This bet is meant to 
	 * mitigate the player's loss in the event that the dealer gets blackjack. However, the player can only bet 50% of their original wager. 
	 * <p>
	 * This method will take input from the player to determine their insurance bet. They can bet 0 if they don't want to bet insurance.
	 * Again, same situation as the splitSituation: any time the player must enter input, it must have its own method.
	 * Will call insuranceSituation() for the next player, or splitSituation() if their is no next player.
	 * </p>
	 * @param playerNode The Node of the Player whose insurance bet will be taken
	 */
	private void insuranceSituation(Node playerNode) {
		Player player = playerNode.getPlayer();
		
		if(player.getCash() <= 0) {
			//player can't bet insurance so call insuranceSituation for another player or turn(p head of list)
			if(playerNode.next == null)
				splitSituation(firstPlayerNode);
			else
				insuranceSituation(playerNode.next);
			return;
			
		}
		
		double maxSideBet = Math.min(player.getCash(), player.getWager()*0.5);
		channel.sendMessageFormat("%s, how much would you like to bet insurance? ($0.00-$%.2f)", player.getUser().getAsMention(), maxSideBet).queue();
		waiter.waitForEvent(MessageReceivedEvent.class,
			(e) -> {
				if(e.getAuthor().isBot() || !e.getAuthor().equals(player.getUser())) {
					return false;
				}
				
				try {
					double i = Double.parseDouble(e.getMessage().getContentRaw());
					if(i < 0) {
						channel.sendMessage("bet must be positive").queue();
						return false;
					}
					
					if(i > player.getWager()*0.5) {
						channel.sendMessage("you're insurance bet can only be at most 50% of your original bet (bet 0 if you don't want to bet insurance)").queue();
						return false;
					}
					
				} catch (Exception x){
					channel.sendMessage("please enter a number").queue();
					return false;
				}
				
				return true;
			}, (e) -> {
				player.setSideBet(Double.parseDouble(e.getMessage().getContentRaw()));
				
				//only do this if playerNode.next == null (otherwise call insuranceSituation for the next player)
				
				if(playerNode.next == null) {
					channel.sendMessage("dealer is checking face down card...").queue();
					if(dealer.hasBlackjack()) { 
						channel.sendMessage(dealer.getHand().get(1).toString()).queue();
						channel.sendMessage("dealer has blackjack!").queue();
						channel.sendMessage("──────────────────────────────────────").queue();
						payout();     
						return;
					}
					turn(firstPlayerNode);
					return;
				}
				
				//if playerNode.next == null and dealer has no blackjack, begin turns, otherwise, insurance bet for next player
				insuranceSituation(playerNode.next);
				return;
			}, 30, TimeUnit.SECONDS, () -> {
				channel.sendMessage("you took too long betting, no side bet set");
				
				if(playerNode.next == null) {
					channel.sendMessage("dealer is checking face down card...").queue();
					if(dealer.hasBlackjack()) { 
						channel.sendMessage(dealer.getHand().get(1).toString()).queue();
						channel.sendMessage("dealer has blackjack!").queue();
						channel.sendMessage("──────────────────────────────────────").queue();
						payout();     
						return;
					}
					
					turn(firstPlayerNode);
					return;
				}
				
				//if playerNode.next == null and dealer has no blackjack, begin turns, otherwise, insurance bet for next player
				insuranceSituation(playerNode.next);
		});
			
	}

	/**
	 * Displays an embedded message that indicates which player's turn it is, that player's hand and its values, and buttons from which that player can indicate their decision.
	 * These buttons include hit, stand, or double down (if the player is able to). 
	 * @param pNode the Node of the Player whose turn it is.
	 */
	private void turn(Node pNode) {
		Player p = pNode.getPlayer();
		
		String effName = p.isSplitHand() ? String.format("%s's split hand", channel.getGuild().getMember(p.getUser()).getEffectiveName()) : channel.getGuild().getMember(p.getUser()).getEffectiveName();
		
		EmbedBuilder eb = new EmbedBuilder()
			.setTitle(effName + "'s turn")
			.setThumbnail(p.getUser().getAvatarUrl())
			.addField("current hand", p.getHand().toString(), false)
			.addField("hand value", p.getHand().value() + "", false)
			.setFooter("use the buttons below to indicate your decision");
		
		
		//if the player is dealt a blackjack immediately, no need to prompt for hit or stand
		if(p.getHand().value() == 21) {
			channel.sendMessageEmbeds(eb.build()).queue();
			channel.sendMessage(p.getUser().getAsMention() + " has blackjack!").queue();
			channel.sendMessage("──────────────────────────────────────").queue();
			
			if(pNode.next == null) {
				dealerTurn();
			} else {
				turn(pNode.next);
			}
			
			return;
		}
		
		ActionRow ar;
		if(p.getWager() <= p.getCash()) {
			ar = ActionRow.of(Button.primary("blackjack:hitbutton", "hit"), Button.secondary("blackjack:standbutton", "stand"), Button.secondary("blackjack:doubledownbutton", "double down"));
		} else {
			ar = ActionRow.of(Button.primary("blackjack:hitbutton", "hit"), Button.secondary("blackjack:standbutton", "stand"));
		}

		channel.sendMessageEmbeds(eb.build()).setComponents(ar)
			.queue( m -> 
				waiter.waitForEvent(ButtonInteractionEvent.class, 
					(e) -> {
						return e.getUser().equals(p.getUser()) && e.getMessageIdLong() == m.getIdLong();
					},
					(e) -> {
						play(pNode, e);
					}, 30, TimeUnit.SECONDS, () -> {
						channel.sendMessage("due to inactivity, " + p.getUser().getAsMention() + " stands").queue();
						
						if(pNode.next == null) {
							dealerTurn();
						} else {
							turn(pNode.next);
						}
						
					}
				)
			);
			
	}
	
	
	/**
	 * When it's a player's turn, they can hit, split, or double down (if they have enough money). When a player hits, they will be dealt another card. Depending on the value of this card and their hand
	 * their turn may end (>=21), or they may hit again (<21). When a player stands, they voluntarily end their turn even if they are able to hit again. When a player doubles down, they double their bet
	 * in exchange for one extra card (they cannot hit again). In addition, a player can only double down as their first choice (e.g. they cannot hit and then double down). 
	 * <p>
	 * Will call play() for the current player if they hit again. 
	 * If the player's turn has ended, will call turn() for the next player or dealerTurn() if there is no next player.
	 * 
	 * @param playerNode The Node of the Player who's playing.
	 * @param event The ButtonInteractionEvent of the player's choice (hit, stand, double down)
	 */
	private void play(Node playerNode, ButtonInteractionEvent event) {
		Player player = playerNode.getPlayer();
		
		//recursively call play until the player busts or stands
		if(event.getComponentId().equals("blackjack:standbutton")) {
			event.editComponents().queue();
			channel.sendMessage(player.getUser().getAsMention() + " stands").queue();
			channel.sendMessage("──────────────────────────────────────").queue();
			
			if(playerNode.next == null) {
				dealerTurn();
			} else {
				turn(playerNode.next);
			}
			
			return;
		}
		
		if(event.getComponentId().equals("blackjack:doubledownbutton")) {
			event.editComponents().queue();
			
			channel.sendMessage(player.getUser().getAsMention() + " doubles down").queue();
			player.doubleWager();
			
			Card dealingCard = deck.deal();
			player.addToHand(dealingCard);
			channel.sendMessage("dealing to " + player.getUser().getAsMention() + ": " + dealingCard + "\nhand value: " + player.getHand().value()).queue();
			
			if(player.getHand().value() > 21 )
				channel.sendMessage(player.getUser().getAsMention() + " busts").queue();
			
			if(player.getHand().value() == 21)
				channel.sendMessage(player.getUser().getAsMention() + " has blackjack!").queue();
			
			channel.sendMessage("──────────────────────────────────────").queue();
			
			if(playerNode.next == null) {
				dealerTurn();
			} else {
				turn(playerNode.next);
			}
			
			return;
			
		}
		
		if(event.getComponentId().equals("blackjack:hitbutton")) {
			
			Card dealingCard = deck.deal();
			player.getHand().add(dealingCard);
			channel.sendMessage("dealing to " + player.getUser().getAsMention() + ": " + dealingCard + "\nhand value: " + player.getHand().value()).queue();
			
			if(player.getHand().size() == 7 && player.getHand().value() <= 21) {
				event.editComponents().queue();
				channel.sendMessage(player.getUser().getAsMention() + " has a 7 card charlie!").queue();
				channel.sendMessage("──────────────────────────────────────").queue();
				
				if(playerNode.next == null) {
					dealerTurn();
				} else {
					turn(playerNode.next);
				}
				
				return;
			}
			
			if(player.getHand().value() > 21) {
				event.editComponents().queue();
				channel.sendMessage(player.getUser().getAsMention() + " busts").queue();
				channel.sendMessage("──────────────────────────────────────").queue();
				
				if(playerNode.next == null) {
					dealerTurn();
				} else {
					turn(playerNode.next);
				}
				
				return;
			}
			
			if(player.getHand().value() == 21) {
				event.editComponents().queue();
				channel.sendMessage(player.getUser().getAsMention() + " has blackjack!").queue();
				channel.sendMessage("──────────────────────────────────────").queue();
				
				if(playerNode.next == null) {
					dealerTurn();
				} else {
					turn(playerNode.next);
				}
				
				return;
			}
			
			ActionRow ar = ActionRow.of(Button.primary("blackjack:hitbutton", "hit"), Button.secondary("blackjack:standbutton", "stand"));
			event.editComponents(ar).queue();
			
			//wait for another hit or stand (then call this method again)
			waiter.waitForEvent(ButtonInteractionEvent.class, 
				e -> {
					return e.getUser().equals(player.getUser()) && e.getMessageIdLong() == event.getMessageIdLong();
				}, 
				e -> { 
					play(playerNode, e);
				}, 30, TimeUnit.SECONDS, () -> { 
					channel.sendMessage("due to inactivity, " + player.getUser().getAsMention() + " stands").queue();
					//send to next method
					if(playerNode.next == null) {
						dealerTurn();
					} else {
						turn(playerNode.next);
					}
					return;
				});
			
		}
	}
	
	/**
	 * Initiates the turn for the dealer. Like a normal player, this method will display the dealer's hand and it's value. The dealer will hit when they're hand is below 17 or
	 * if they're on a "soft" 17. A 17 is considered "soft" when they have an ace who's value is 11. 
	 */
	private void dealerTurn() {
		EmbedBuilder eb = new EmbedBuilder()
				.setTitle("dealer's turn")
				.addField("current hand", dealer.getHand().toString(), false)
				.addField("hand value", dealer.getHand().value()+"", false)
				.setDescription("please wait")
				.setThumbnail(channel.getJDA().getSelfUser().getAvatarUrl());
		
		channel.sendMessageEmbeds(eb.build()).queue();
		channel.sendMessage("dealer's down card is... " + dealer.getHand().get(1) + "\nhand value: " + dealer.getHand().value()).queue();
		
		Card dealingCard;
		while(dealer.getHand().value() < 17 || (dealer.getHand().value() == 17 && dealer.getHand().getSoft())) {
			dealingCard = deck.deal();
			dealer.addToHand(dealingCard);
			channel.sendMessage("dealing to DEALER: " + dealingCard + "\nhand value: " + dealer.getHand().value()).queue();
		}
		
		//displays the result of the dealer's turn
		if(dealer.getHand().value() > 21) {
			channel.sendMessage("dealer busts").queue();
		}else if(dealer.hasBlackjack()) {
			channel.sendMessage("dealer has blackjack!").queue();
		}else {
			 channel.sendMessage("dealer stands").queue();
		}
		
		channel.sendMessage("──────────────────────────────────────").queue();
		payout();
	}
	
	/**
	 * Displays all of the player's profits or losses from a given round. Beating the dealer and winning insurance bets pays 2:1, while winning blackjack pays 3:2
	 * If the player has lost to the dealer or busted, they forfeit their bet. If the player's hand matches the dealer, they are paid back their original bet.
	 */
	private void payout() {
		clearSplits();
		
		EmbedBuilder eb = new EmbedBuilder()
				.setTitle("payout")
				.setThumbnail(channel.getJDA().getSelfUser().getAvatarUrl());
		for(Node ptr = firstPlayerNode; ptr != null; ptr = ptr.next) {
			Player player = ptr.getPlayer();
			eb.addField(channel.getGuild().getMember(player.getUser()).getEffectiveName(), evaluatePay(player), false);
		}
		
		channel.sendMessageEmbeds(eb.build()).queue();
		
		endgame();
	}
	
	/** 
	 * Evaluates the pay for a certain player.
	 * </p>
	 * Postconditions:
	 * <ul>
	 * 	<li>if the player's hand is more than 21, they bust and the bet is forfeit</li>
	 * 	<li>if the dealer's hand is more than 21, all remaining players win (they get their bet back and win an additional amount equals to their bet)</li>
	 * 	<li>if the player's hand is equal to the dealer's hand, the player pushes (wins nothing, loses nothing)</li>
	 * 	<li>if the player's hand is equal to 21,  the player wins with an increased payout (x1.5)</li>
	 * 	<li>if the player's hand is greater than the dealer's hand, the player wins</li>
	 * 	<li>if the player's hand is less than the dealer's,  their bet is forfeit</li>
	 *  <li>if the player has bet insurance, their bet is paid back if the dealer's down card value is 10</li>
	 * 
	 * </p>
	 * These ifs are tested in this order, such that some possibilities are ruled out as it progresses
	 * (e.g. this cancels situations like: 
	 * paying out to player because the player has a higher hand value, but the player has busted.)
	 * <p>
	 * @param p the player whose pay is being evaluated
	 */
	private String evaluatePay(Player p) {
		String result = "";
		String name = !p.isSplitHand() ? channel.getGuild().getMember(p.getUser()).getEffectiveName() : channel.getGuild().getMember(p.getUser()).getEffectiveName() + "'s split hand";
		
		if(p.getHand().value() > 21) {
			result = String.format("%s has busted. (-$%.2f)", name, p.getWager());
		}else if(dealer.getHand().value() > 21) {
			if(!p.hasBlackjack()) {
				result = String.format("dealer has busted. %s has won. (+$%.2f)", name, p.getWager());
				p.addCash(p.getWager()*2);
			}else {
				result = String.format("dealer has busted. %s has won with blackjack. (+$%.2f)", name, p.getWager()*1.5);
				p.addCash(p.getWager()*2.5);
			}
		}else if(p.getHand().value() == dealer.getHand().value()) {
			result = name + " pushes. (+$0)";
			p.addCash(p.getWager());
		}else if(p.hasBlackjack()) {
			result = String.format("%s has won with blackjack. (+$%.2f)", name, p.getWager()*1.5);
			p.addCash(p.getWager()*2.5);
		}else if(p.getHand().value() > dealer.getHand().value() || p.getHand().size() == 7) {
			result = String.format("%s has won. (+$%.2f)", name, p.getWager());
			p.addCash(p.getWager()*2);
		}else if(p.getHand().value() < dealer.getHand().value()) {
			result = String.format("%s has lost. (-$%.2f)", name, p.getWager());
		}
		
		//evaluates pay for split bet and pays accordingly
		if(p.getSplitHand() != null) {
			p.getSplitHand().addCash(-p.getSplitHand().getCash());
			result += "\n" + evaluatePay(p.getSplitHand());
			p.addCash(p.getSplitHand().getCash());
		}
		
		//evaluates pay for side/insurance bet and pays accordingly
		if(p.getSideBet()!=0 && dealer.hasBlackjack() && dealer.getHand().size()==2) {
			result += String.format("\n%s has also bet for insurance and won (+$%.2f)", name, p.getSideBet());
			p.addCash(p.getSideBet()*2);
		}else if(p.getSideBet()!=0) {
			result += String.format("\n%s has also bet for insurance and lost (-$%.2f)", name, p.getSideBet());
		}
		
		return result;
	}
	
	/**
	 * When a player has a split hand, their split hand becomes a playerNode that's inserted right after the player's original node. This method gets rid of all of them
	 * so that all the player's balances can be displayed properly.
	 */
	private void clearSplits() {
		for(Node ptr = firstPlayerNode; ptr != null; ptr = ptr.next) { 
			//should be fine because the firstPlayerNode should never be a split hand
			if(ptr.getPlayer().isSplitHand()) {
				ptr.prev.next = ptr.next;
			}
		}
	}

	/**
	 * endgame() as in endgame, not as in to end game. </p>
	 * This method is called at the end of the round, after all the players have played their turns and the dealer has played theirs. Prompts the game leader (player of the first node)
	 * to continue or end the game. If all the players have ran out of money, then the game will end automatically.
	 */
	private void endgame() {
		EmbedBuilder eb = new EmbedBuilder();
		boolean allPlayersBroke = clearBrokePlayers();
		
		if(allPlayersBroke) {
			channel.sendMessage("all players have ran out of money, ending game").queue();
			channel.sendMessage("──────────────────────────────────────").queue();
			stop();
			return;
		}
		
		eb.setTitle("round has ended")
			.setDescription("do you wish to continue?")
			.setThumbnail(channel.getJDA().getSelfUser().getAvatarUrl());
				
		channel.sendMessageEmbeds(eb.build()).setActionRow(Button.success("blackjack:continuebutton", "continue"), Button.danger("blackjack:end_game_button", "end game"), Button.secondary("blackjack:leave_game_button", "leave game")).queue(msg ->
		waiter.waitForEvent(ButtonInteractionEvent.class, e -> {
			return  !e.getComponentId().equals("blackjack:leave_game_button") 
						&& e.getMessageIdLong() == msg.getIdLong()
						&& (e.getUser().equals(firstPlayerNode.getPlayer().getUser()) || channel.getGuild().getMember(e.getUser()).hasPermission(Permission.MANAGE_SERVER));
		},
		e -> {

			if(e.getComponentId().equals("blackjack:continuebutton")) {
				e.editComponents().queue();
				channel.sendMessage("continuing game").queue();
				channel.sendMessage("──────────────────────────────────────").queue();
				run();
				return;
			}
			
			if(e.getComponentId().equals("blackjack:end_game_button")) {
				e.editComponents().queue();
				channel.sendMessage("──────────────────────────────────────").queue();
				stop();
				return;
			}

		}, 90, TimeUnit.SECONDS, () -> {
			if(firstPlayerNode == null)
				return;
			
			channel.sendMessage("received no response, stopping game").queue();
			channel.sendMessage("──────────────────────────────────────").queue();
			stop();
			return;
		}));
	}
	
	/**
	 * Removes players with no money from the linked list of players.
	 * @return true if all the players in the list have no money
	 */
	private boolean clearBrokePlayers() {
		boolean allPlayersBroke = true;
		
		for(Node ptr = firstPlayerNode; ptr != null; ptr = ptr.next) {
			if(ptr.getPlayer().getCash() <= 0.001) {
				channel.sendMessage(ptr.getPlayer().getUser().getAsMention() +  " has lost all their money, removing them from the game").queue();
				saveSinglePlayer(ptr.getPlayer());

				if(ptr == firstPlayerNode) {
					if(firstPlayerNode.next == null) {
						return true;
					}
					
					firstPlayerNode = firstPlayerNode.next;
					break;
				}
				
				if(ptr.next != null)
					ptr.next.prev = ptr.prev;
	
				ptr.prev.next = ptr.next;
			} else {
				allPlayersBroke = false;
			}
		}
		
		return allPlayersBroke;
	}
	
	public void removePlayer(User user, ButtonInteractionEvent event) {
		for(Node ptr = firstPlayerNode; ptr != null; ptr = ptr.next) { 
			if(ptr.getPlayer().getUser().getIdLong() == user.getIdLong()) {
				String str = String.format("%s has left the game with $%.2f", ptr.getPlayer().getUser().getAsMention(), ptr.getPlayer().getCash());
				channel.sendMessage(str).queue();
				saveSinglePlayer(ptr.getPlayer());
				
				if(ptr == firstPlayerNode) {
					if(firstPlayerNode.next == null) {
						event.editComponents().queue();
						channel.sendMessage("all players have left the game, ending game").queue();
						channel.sendMessage("──────────────────────────────────────").queue();
						stop();
						return;
					}
					
					event.deferEdit().queue();
					firstPlayerNode = firstPlayerNode.next;
					return;
				}
				
				event.deferEdit().queue();
				if(ptr.next != null)
					ptr.next.prev = ptr.prev;
				ptr.prev.next = ptr.next;
				return;
			}
		}
		
		event.reply("you aren't playing in this game").setEphemeral(true).queue();
	}

	/**
	 * Displays a message including everyone's final balances, and then ends the game (dereferences all its members and then itself). 
	 */
	public void stop() {
		started = false;
		BlackjackManager.getInstance().getGameManager(channel.getGuild()).started = false;
		
		EmbedBuilder eb = new EmbedBuilder()
				.setTitle("thanks for playing blackjack")
				.setDescription("here's how you did")
				.setFooter("by mute | https://github.com/mvte")
				.setThumbnail(channel.getJDA().getSelfUser().getAvatarUrl());
		
		for(Node ptr = firstPlayerNode; ptr != null; ptr = ptr.next) {
			Player player = ptr.getPlayer();
			eb.addField(channel.getGuild().getMember(player.getUser()).getEffectiveName(), String.format("$%.2f", player.getCash()), false);
		}
			
		channel.sendMessageEmbeds(eb.build()).queue();
		saveAllPlayers();
		
		this.players = null;
		firstPlayerNode = null;
		BlackjackManager.getInstance().getGameManager(channel.getGuild()).nullGame();
	}

	private void saveSinglePlayer(Player player) {
		try {
			Statement stmt = conn.createStatement();
			stmt.executeUpdate("update amounts set cash = " + player.getCash()
					+ " where id = " + player.getUser().getIdLong() + ";");
		} catch (SQLException e) {
			channel.sendMessage("error saving player after leave! their money will not be saved").queue();
			e.printStackTrace();
		}
	}

	private void saveAllPlayers() {
		try {
			conn.setAutoCommit(false);
			String update = "update amounts set cash = ? where id = ?";
			PreparedStatement ps = conn.prepareStatement(update);

			for(Node ptr = firstPlayerNode; ptr != null; ptr = ptr.next) {
				Player player = ptr.getPlayer();
				ps.setDouble(1, player.getCash());
				ps.setLong(2, player.getUser().getIdLong());
				ps.addBatch();
			}

			ps.executeBatch();
			conn.commit();
			conn.setAutoCommit(true);
		} catch (SQLException e) {
			channel.sendMessage("error saving to database, this game will not be saved").queue();
			e.printStackTrace();
		}
	}
}
